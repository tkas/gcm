#include <config/Configuration.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <util/Log.h>

#ifndef _GNU_SOURCE
# define _GNU_SOURCE
#endif

#include <string.h>

using namespace GCM::config;
using namespace GCM;

Configuration::Configuration(): Object() {}

void GCM_API Configuration::load(const char *filename) {
	FILE *f = fopen(filename, "r");
	this->fileName = filename;

	if (f) {
		char linebuf[1024];
		while (fgets(linebuf, 1024, f)) {
			// Got line, need to parse it.

			char *line = linebuf;

			// Trim from left
			while (*line != '\0' && isspace(*line)) ++line;

			// Trim from right
			size_t i = strlen(line) - 1;
			while (i > 0 && isspace(line[i])) {
				line[i] = '\0';
				--i;
			}

			// Comment
			if (*line == ';') {
				continue;
			}

			// Empty line
			if (*line == '\0') {
				continue;
			}

			char *assignment = strstr(line, "=");
			if (assignment != NULL) {
				// Got assignment.
				*assignment = '\0';

				char *value = assignment + 1;

				// Trim value from left
				while (*value != '\0' && isspace(*value)) value++;

				// Trim name from right
				char *name = line;
				i = strlen(name) - 1;
				while (i > 0 && isspace(name[i])) {
					name[i] = '\0';
					--i;
				}

				// Not empty value, not empty name
				if (*value != '\0' && *name != '\0') {
					char *endptrDouble, *endptrInt;
					double doubleval = strtod(value, &endptrDouble);
					long intval = strtol(value, &endptrInt, 10);

					sValue sval;

					// The value is int
					if (*endptrInt == '\0') {
						sval.type = VAL_INT;
						sval.value.asInt = intval;
					// The value is double
					} else if (*endptrDouble == '\0') {
						sval.type = VAL_DOUBLE;
						sval.value.asDouble = doubleval;
					// The value is string
					} else {
						sval.type = VAL_STRING;
						sval.value.asString = strdup(value);
					}

					// Free old string, if reloading new.
					std::map<std::string, sValue>::iterator i = data.find(name);
					if (i != data.end()) {
						if (i->second.type == VAL_STRING) {
							free(i->second.value.asString);
						}
					}

					data[name] = sval;
				}

			} else {
				// Empty or gibrish line...
			}
		}
		fclose(f);
	}

	// Debug...
	/*
	std::map<std::string, sValue>::iterator i = data.begin();
	while (i != data.end()) {
		switch (i->second.type) {
			case VAL_INT:
				GCM::util::Log::d("Configuration", "Got %s = %d (int)", i->first.c_str(), i->second.value.asInt);
				break;

			case VAL_DOUBLE:
				GCM::util::Log::d("Configuration", "Got %s = %lf (double)", i->first.c_str(), i->second.value.asDouble);
				break;

			case VAL_STRING:
				GCM::util::Log::d("Configuration", "Got %s = %s (string)", i->first.c_str(), i->second.value.asString);
				break;
		}

		i++;
	}
	*/
}

void GCM_API Configuration::write(const char *filename) {
	FILE *f = fopen(filename, "w");
	if (f) {
		fprintf(f, ";%s\r\n", "Autogenerated file");

		std::map<std::string, sValue>::iterator i = data.begin();
		while (i != data.end()) {
			fprintf(f, "%s=", i->first.c_str());

			switch (i->second.type) {
				case VAL_INT:
					fprintf(f, "%ld", i->second.value.asInt);
					break;

				case VAL_DOUBLE:
					fprintf(f, "%lf", i->second.value.asDouble);
					break;

				case VAL_STRING:
					fprintf(f, "%s", i->second.value.asString);
					break;

				default:
					break;
			}

			fprintf(f, "\r\n");

			i++;
		}

		fclose(f);
	}
}

void GCM_API Configuration::set(const char *name, long value) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end() && i->second.type == VAL_STRING) {
		free(i->second.value.asString);
	}

	sValue sval;
	sval.type = VAL_INT;
	sval.value.asInt = value;

	data[name] = sval;
}

void GCM_API Configuration::set(const char *name, int value) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end() && i->second.type == VAL_STRING) {
		free(i->second.value.asString);
	}

	sValue sval;
	sval.type = VAL_INT;
	sval.value.asInt = value;

	data[name] = sval;
}

void GCM_API Configuration::set(const char *name, const char *value) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end() && i->second.type == VAL_STRING) {
		free(i->second.value.asString);
	}

	sValue sval;
	sval.type = VAL_STRING;
	sval.value.asString = strdup(value);

	data[name] = sval;
}

void GCM_API Configuration::set(const char *name, double value) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end() && i->second.type == VAL_STRING) {
		free(i->second.value.asString);
	}

	sValue sval;
	sval.type = VAL_DOUBLE;
	sval.value.asDouble = value;

	data[name] = sval;
}

void GCM_API Configuration::set(const char *name, String value) {
	this->set(name, value->c_str());
}

bool GCM_API Configuration::keyExists(const char *key) {
	std::map<std::string, sValue>::iterator i = data.find(key);
	if (i != data.end()) {
		return true;
	}
	return false;
}

void GCM_API Configuration::unset(const char *key) {
	std::map<std::string, sValue>::iterator i = data.find(key);
	if (i != data.end()) {
		if (i->second.type == VAL_STRING) {
			free(i->second.value.asString);
		}
		
		data.erase(i);
	}
}

long GCM_API Configuration::getInt(const char *name, long defaultValue) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end()) {
		switch (i->second.type) {
			case VAL_INT:
				return i->second.value.asInt;

			case VAL_DOUBLE:
				return i->second.value.asDouble;

			case VAL_STRING:
				return strtol(i->second.value.asString, NULL, 10);

			default:
				return defaultValue;
		}
	} else {
		return defaultValue;
	}
}

const char GCM_API *Configuration::getString(const char *name, const char *defaultValue) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end()) {
		int size;

		switch (i->second.type) {
			case VAL_INT:
				i->second.type = VAL_STRING;
				size = snprintf(NULL, 0, "%ld", i->second.value.asInt) + 1;
				i->second.value.asString = (char *)malloc(size * sizeof(char));
				snprintf(i->second.value.asString, size, "%ld", i->second.value.asInt);

				return i->second.value.asString;

			case VAL_DOUBLE:
				i->second.type = VAL_STRING;
				size = snprintf(NULL, 0, "%lf", i->second.value.asDouble) + 1;
				i->second.value.asString = (char *)malloc(size * sizeof(char));
				snprintf(i->second.value.asString, size, "%lf", i->second.value.asDouble);

				return i->second.value.asString;

			case VAL_STRING:
				return i->second.value.asString;

			default:
				return defaultValue;
		}
	} else {
		return defaultValue;
	}
}

double GCM_API Configuration::getDouble(const char *name, double defaultValue) {
	std::map<std::string, sValue>::iterator i = data.find(name);
	if (i != data.end()) {
		switch (i->second.type) {
			case VAL_INT:
				return i->second.value.asInt;

			case VAL_DOUBLE:
				return i->second.value.asDouble;

			case VAL_STRING:
				return strtod(i->second.value.asString, NULL);

			default:
				return defaultValue;
		}
	} else {
		return defaultValue;
	}
}

GCM_API Configuration::~Configuration() {
	std::map<std::string, sValue>::iterator i = data.begin();
	while (i != data.end()) {
		if (i->second.type == VAL_STRING) {
			free(i->second.value.asString);
		}

		i++;
	}
}

const char GCM_API *Configuration::getFileName() {
	return this->fileName.c_str();
}

void GCM_API Configuration::setFileName(const char *fileName) {
	this->fileName = fileName;
}

void GCM_API Configuration::write() {
	this->write(this->fileName.c_str());
}
