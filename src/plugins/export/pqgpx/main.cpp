#include <gcm.h>
#include <export.h>
#include <stdio.h>
#include <time.h>

#include <database/Database.h>

#include <geolib/GeocacheList.h>
#include <geolib/AttributeSet.h>
#include <geolib/Attribute.h>
#include <geolib/LogList.h>
#include <geolib/Log.h>

#include <util/File.h>
#include <pluginmanager/Plugin.h>

using namespace GCM;
using namespace GCM::geolib;
using namespace GCM::io;
using namespace GCM::pluginmanager;

String htmlspecialchars(String in) {
	return in
		->replace("&", "&amp;")
		->replace("<", "&lt;")
		->replace(">", "&gt;");
}

bool exportPqGpx(GC<GeocacheList> list, File outFile, ptrDialog progressDialog) {
	FILE *f = fopen(outFile->getAbsolutePath()->c_str(), "w");
	if (!f) return false;

	struct tm currtime;
	time_t now;
	time(&now);
	gmtime_r(&now, &currtime);

	// Write header
	fprintf(f,
		"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n"
		"<gpx xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
			"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" "
			"version=\"1.0\" "
			"creator=\"Groundspeak, Inc. All Rights Reserved. http://www.groundspeak.com\" "
			"xsi:schemaLocation=\"http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0/1 http://www.groundspeak.com/cache/1/0/1/cache.xsd\" "
			"xmlns=\"http://www.topografix.com/GPX/1/0\">\r\n"
		"  <name>PocketQuery Export from GCManager</name>\r\n"
		"  <desc>Geocache file generated by Groundspeak</desc>\r\n"
		"  <author>Groundspeak</author>\r\n"
		"  <email>contact@groundspeak.com</email>\r\n"
		"  <time>%04d-%02d-%02dT%02d:%02d:%02d.%05dZ</time>\r\n",
			currtime.tm_year + 1900, currtime.tm_mon + 1, currtime.tm_mday,
			currtime.tm_hour, currtime.tm_min, currtime.tm_sec, 0);

	// Find out bounds
	int minLat, minLon, maxLat, maxLon;
	GeocacheList::iterator i = list->begin();
	while (i != list->end()) {
		if (i == list->begin()) {
			maxLat = minLat = (*i)->getLatitudeE6();
			maxLon = minLon = (*i)->getLongitudeE6();
		} else {
			if (maxLat < (*i)->getLatitudeE6()) maxLat = (*i)->getLatitudeE6();
			if (maxLon < (*i)->getLongitudeE6()) maxLon = (*i)->getLongitudeE6();
			if (minLat > (*i)->getLatitudeE6()) minLat = (*i)->getLatitudeE6();
			if (minLon > (*i)->getLongitudeE6()) minLon = (*i)->getLongitudeE6();
		}

		if ((*i)->isWaypointsLoaded()) {
			GC<GeocacheWaypointList> waypoints = (*i)->getWaypoints();
			GeocacheWaypointList::iterator wi = waypoints->begin();
			while (wi != waypoints->end()) {
				if (maxLat < (*wi)->getLatitudeE6()) maxLat = (*wi)->getLatitudeE6();
				if (maxLon < (*wi)->getLongitudeE6()) maxLon = (*wi)->getLongitudeE6();
				if (minLat > (*wi)->getLatitudeE6()) minLat = (*wi)->getLatitudeE6();
				if (minLon > (*wi)->getLongitudeE6()) minLon = (*wi)->getLongitudeE6();

				wi++;
			}
		}

		i++;
	}

	fprintf(f,
		"  <keywords>cache, geocache, groundspeak</keywords>\r\n"
		"  <bounds minlat=\"%lf\" minlon=\"%lf\" maxlat=\"%lf\" maxlon=\"%lf\" />\r\n",
		minLat / 1E6, minLon / 1E6, maxLat / 1E6, maxLon / 1E6);

	progressDialog->setMaxProgress(list->size());

	i = list->begin();
	while (i != list->end()) {
		GC<Geocache> &cache = (*i);

		if (cache->getDbProvider()) {
			if (!cache->isAttributesLoaded()) cache->getDbProvider()->loadAttributes(cache);
			if (!cache->isLogsLoaded()) cache->getDbProvider()->loadLogs(cache);
			if (!cache->isLongLoaded()) cache->getDbProvider()->loadLongData(cache);
		}

		fprintf(f,
			"  <wpt lat=\"%lf\" lon=\"%lf\">\r\n",
			cache->getLatitude(), cache->getLongitude());

		struct tm dtCreated;
		time_t tmCreated = cache->getDtCreated();
		localtime_r(&tmCreated, &dtCreated);

		fprintf(f,
			"    <time>%04d-%02d-%02dT07:00:00Z</time>\r\n",
			dtCreated.tm_year + 1900, dtCreated.tm_mon + 1, dtCreated.tm_mday);

		char diff[4], terr[4];

		if (cache->getDifficulty() % 10 == 5) {
			snprintf(diff, 4, "%1.1f", cache->getDifficulty() / 10.0);
		} else {
			snprintf(diff, 4, "%d", (int)(cache->getDifficulty() / 10));
		}

		if (cache->getTerrain() % 10 == 5) {
			snprintf(terr, 4, "%1.1f", cache->getTerrain() / 10.0);
		} else {
			snprintf(terr, 4, "%d", (int)(cache->getTerrain() / 10));
		}

		fprintf(f,
			"    <name>%s</name>\r\n"
			"    <desc>%s by %s, %s (%s/%s)</desc>\r\n"
			"    <url>http://www.geocaching.com/seek/cache_details.aspx?wp=%s</url>\r\n"
			"    <urlname>%s</urlname>\r\n"
			"    <sym>%s</sym>\r\n"
			"    <type>Geocache|%s</type>\r\n",
			htmlspecialchars(cache->getId())->c_str(),
			htmlspecialchars(cache->getName())->c_str(),
			htmlspecialchars(cache->getPlacedBy())->c_str(),
			(cache->isFound())?"Geocache Found":"Geocache",
			Geocache::typeToGpxString(cache->getCacheType())->c_str(),
			diff, terr,
			htmlspecialchars(cache->getId())->c_str(),
			htmlspecialchars(cache->getName())->c_str(),
			Geocache::typeToGpxString(cache->getCacheType())->c_str());

		fprintf(f,
			"    <groundspeak:cache id=\"%d\" "
				"available=\"%s\" "
				"archived=\"%s\" "
				"xmlns:groundspeak=\"http://www.groundspeak.com/cache/1/0/1\">\r\n",
				cache->getRowId(),
				(cache->isAvailable())?"True":"False",
				(cache->isArchived())?"True":"False");

		fprintf(f,
			"      <groundspeak:name>%s</groundspeak:name>\r\n"
			"      <groundspeak:placed_by>%s</groundspeak:placed_by>\r\n"
			"      <groundspeak:owner id=\"%d\">%s</groundspeak:owner>\r\n"
			"      <groundspeak:type>%s</groundspeak:type>\r\n"
			"      <groundspeak:container>%s</groundspeak:container>\r\n",
			htmlspecialchars(cache->getName())->c_str(),
			htmlspecialchars(cache->getPlacedBy())->c_str(),
			cache->getOwnerId().get(),
			htmlspecialchars(cache->getOwner())->c_str(),
			Geocache::typeToGpxString(cache->getCacheType())->c_str(),
			Geocache::sizeToGpxString(cache->getSize())->c_str());

		if (cache->isAttributesLoaded()) {
			fprintf(f,
				"      <groundspeak:attributes>\r\n");

			GC<AttributeSet> attributes = cache->getAttributes();
			AttributeSet::iterator ai = attributes->begin();
			while (ai != attributes->end()) {
				fprintf(f,
					"        <groundspeak:attribute id=\"%d\" inc=\"%d\">%s</groundspeak:attribute>\r\n",
					ai->second->getId(),
					(int)(ai->second->isPositive()),
					htmlspecialchars(Attribute::getKnownAttributes()[ai->first])->c_str());

				ai++;
			}

			fprintf(f,
				"      </groundspeak:attributes>\r\n");
		}

		fprintf(f,
			"      <groundspeak:difficulty>%s</groundspeak:difficulty>\r\n"
			"      <groundspeak:terrain>%s</groundspeak:terrain>\r\n"
			"      <groundspeak:country>%s</groundspeak:country>\r\n"
			"      <groundspeak:state>%s</groundspeak:state>\r\n",
			diff, terr,
			htmlspecialchars(cache->getCountry())->c_str(),
			htmlspecialchars(cache->getState())->c_str());

		if (cache->isLongLoaded()) {
			fprintf(f,
				"      <groundspeak:short_description html=\"%s\">%s</groundspeak:short_description>\r\n",
				(cache->getSDIsHTML())?"True":"False",
				htmlspecialchars(cache->getShortDescription())->c_str());

			fprintf(f,
				"      <groundspeak:long_description html=\"%s\">%s</groundspeak:long_description>\r\n",
				(cache->getLDIsHTML())?"True":"False",
				htmlspecialchars(cache->getLongDescription())->c_str());

			fprintf(f,
				"      <groundspeak:encoded_hints>%s</groundspeak:encoded_hints>\r\n",
				htmlspecialchars(cache->getHint())->c_str());
		}

		if (cache->isLogsLoaded()) {
			fprintf(f,
				"      <groundspeak:logs>\r\n");

			GC<LogList> logs = cache->getLogs();
			LogList::iterator li = logs->begin();
			while (li != logs->end()) {
				GC<Log> log = (*li);
				struct tm logTime;
				time_t logTm = log->getTime();
				localtime_r(&logTm, &logTime);

				fprintf(f,
					"        <groundspeak:log id=\"%d\">\r\n"
					"          <groundspeak:date>%04d-%02d-%02dT%02d:00:00Z</groundspeak:date>\r\n"
					"          <groundspeak:type>%s</groundspeak:type>\r\n"
					"          <groundspeak:finder id=\"%d\">%s</groundspeak:finder>\r\n"
					"          <groundspeak:text encoded=\"%s\">%s</groundspeak:text>\r\n"
					"        </groundspeak:log>\r\n",
					log->getId(),
					logTime.tm_year + 1900, logTime.tm_mon + 1, logTime.tm_mday,
					(logTime.tm_isdst)?19:20,
					Log::typeToGpxString(log->getType())->c_str(),
					log->getFinderId(),
					htmlspecialchars(log->getFinder())->c_str(),
					(log->isTextEncoded())?"True":"False",
					htmlspecialchars(log->getText())->c_str());

				li++;
			}

			fprintf(f,
				"      </groundspeak:logs>\r\n");
		}

		fprintf(f,
			"      <groundspeak:travelbugs />\r\n"
			"    </groundspeak:cache>\r\n"
			"  </wpt>\r\n");

		// Export child waypoints
		if (cache->isWaypointsLoaded()) {
			GC<GeocacheWaypointList> waypoints = cache->getWaypoints();
			GeocacheWaypointList::iterator wi = waypoints->begin();
			while (wi != waypoints->end()) {
				GC<GeocacheWaypoint> waypoint = (*wi);
				fprintf(f, "  <wpt lat=\"%lf\" lon=\"%lf\">\r\n",
					waypoint->getLatitude(), waypoint->getLongitude());

				fprintf(f,
					"    <time>%04d-%02d-%02dT00:00:00.000</time>\r\n"
					"    <name>%s</name>\r\n",
					dtCreated.tm_year + 1900, dtCreated.tm_mon + 1, dtCreated.tm_mday,
					htmlspecialchars(waypoint->getId())->c_str());

				if (!waypoint->getComment()->equals("")) {
					fprintf(f, "    <cmt>%s</cmt>\r\n",
						htmlspecialchars(waypoint->getComment())->c_str());
				} else {
					fprintf(f, "    <cmt />\r\n");
				}

				// I know URL of the waypoint does not work this way, but who really cares?
				fprintf(f,
					"    <desc>%s</desc>\r\n"
					"    <url>http://www.geocaching.com/seek/wpt.aspx?wp=%s</url>\r\n"
					"    <urlname>%s</urlname>\r\n"
					"    <sym>%s</sym>\r\n"
					"    <type>Waypoint|%s</type>\r\n",
					htmlspecialchars(waypoint->getName())->c_str(),
					htmlspecialchars(waypoint->getId())->c_str(),
					htmlspecialchars(waypoint->getName())->c_str(),
					GeocacheWaypoint::typeToGpxString(waypoint->getWptType())->c_str(),
					GeocacheWaypoint::typeToGpxString(waypoint->getWptType())->c_str());

				fprintf(f, "  </wpt>\r\n");

				wi++;
			}
		}

		i++;
		progressDialog->setProgress(progressDialog->getProgress() + 1);
	}

	// Write footer
	fprintf(f, "</gpx>\r\n");

	fclose(f);
	return true;
}

class MyExportInfo: public GCM::ExportInfo {
	public:
		MyExportInfo(String id, String name, String extension): GCM::ExportInfo(id, name, extension) {}

		virtual bool exportList(GC<GeocacheList> list, File outFile, ptrDialog progressDialog) {
			return exportPqGpx(list, outFile, progressDialog);
		}
};

GC< List<ExportInfo> > exportInfo() {
	GC< List<ExportInfo> > list = new List<ExportInfo>();

	list->append(new MyExportInfo(
		"pqgpx",
		"PocketQuery GPX",
		"gpx"
	));

	return list;
}

PLUGIN_EXPORT void gcm_pluginInit(Plugin *plugin) {
	plugin->author = "Niximor";
	plugin->version.major = 1;
	plugin->version.minor = 0;
	plugin->manager.registerFunction(plugin, "Export", callback(exportInfo));
}

PLUGIN_EXPORT void gcm_pluginDone(Plugin *plugin) {
	(void)plugin;
}
